use std::{
    ops::Index,
    sync::Arc,
};

mod constraints;
mod type_variable;
pub use type_variable::TypeVarId;

use crate::{arena::map::ArenaMap, ty::infer::constraints::ConstraintSystem, Ty, ExprId, PatId, HirDatabase, Function, diagnostics::DiagnosticSink, code_model::DefWithBody, Pat, HirDisplay};

/// The result of type inference: A mapping from expressions and patterns to types.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct InferenceResult {
    type_of_expr: ArenaMap<ExprId, Ty>,
    type_of_pat: ArenaMap<PatId, Ty>,
    diagnostics: Vec<diagnostics::InferenceDiagnostic>,
}

impl Index<ExprId> for InferenceResult {
    type Output = Ty;

    fn index(&self, expr: ExprId) -> &Ty {
        self.type_of_expr.get(expr).unwrap_or(&Ty::Unknown)
    }
}

impl Index<PatId> for InferenceResult {
    type Output = Ty;

    fn index(&self, pat: PatId) -> &Ty {
        self.type_of_pat.get(pat).unwrap_or(&Ty::Unknown)
    }
}

impl InferenceResult {
    pub(crate) fn add_diagnostics(
        &self,
        db: &impl HirDatabase,
        owner: Function,
        sink: &mut DiagnosticSink,
    ) {
        self.diagnostics
            .iter()
            .for_each(|it| it.add_to(db, owner, sink))
    }
}

/// The entry point of type inference.
pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {
    // Get the body from the definition and create a solver that can be used to resolve names.
    let body = def.body(db);
    let resolver = def.resolver(db);

    // Build a constraint system from the body and resolver
    let (mut constraints, diagnostics) = ConstraintSystem::from_body(db, body.clone(), resolver);

    let mut solutions = Vec::new();

    println!("-- Initial constraints");
    let could_simplify = constraints.simplify();
    constraints.print(db, &body);

    if could_simplify {
        constraints.solve(&mut solutions);
        assert_ne!(solutions.len(), 0);
    }

    for (i, solution) in solutions.iter().enumerate() {
        println!("-- Solution #{}", i);
        // Print all patterns
        for (pat, ty) in solution.type_of_pat.iter() {
            match &body[pat] {
                Pat::Bind { name } => {
                    println!("{} := {}", name, ty.display(db));
                }
                _ => {}
            }
        }
    }

    let solution = match solutions.into_iter().next() {
        Some(solution) => solution,
        None => panic!("Could not find a solution")
    };

    Arc::new(InferenceResult {
        type_of_expr: solution.type_of_expr,
        type_of_pat: solution.type_of_pat,
        diagnostics
    })
}

#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub(super) enum ExprOrPatId {
    ExprId(ExprId),
    PatId(PatId),
}

impl From<ExprId> for ExprOrPatId {
    fn from(e: ExprId) -> Self {
        ExprOrPatId::ExprId(e)
    }
}

impl From<PatId> for ExprOrPatId {
    fn from(p: PatId) -> Self {
        ExprOrPatId::PatId(p)
    }
}

mod diagnostics {
    use crate::diagnostics::{CannotApplyBinaryOp, MismatchedType};
    use crate::{
        code_model::src::HasSource,
        diagnostics::{DiagnosticSink, UnresolvedType, UnresolvedValue},
        ty::infer::ExprOrPatId,
        type_ref::TypeRefId,
        ExprId, Function, HirDatabase, Ty,
    };

    #[derive(Debug, PartialEq, Eq, Clone)]
    pub(super) enum InferenceDiagnostic {
        UnresolvedValue { id: ExprOrPatId },
        UnresolvedType { id: TypeRefId },
        MismatchedTypes { id: ExprId, expected: Ty, found: Ty },
        CannotApplyBinaryOp { id: ExprId, lhs: Ty, rhs: Ty },
    }

    impl InferenceDiagnostic {
        pub(super) fn add_to(
            &self,
            db: &impl HirDatabase,
            owner: Function,
            sink: &mut DiagnosticSink,
        ) {
            match self {
                InferenceDiagnostic::UnresolvedValue { id } => {
                    let file = owner.source(db).file_id;
                    let body = owner.body_source_map(db);
                    let expr = match id {
                        ExprOrPatId::ExprId(id) => body.expr_syntax(*id),
                        ExprOrPatId::PatId(id) => {
                            body.pat_syntax(*id).map(|ptr| ptr.syntax_node_ptr())
                        }
                    }
                    .unwrap();

                    sink.push(UnresolvedValue { file, expr });
                }
                InferenceDiagnostic::UnresolvedType { id } => {
                    let file = owner.source(db).file_id;
                    let body = owner.body_source_map(db);
                    let type_ref = body.type_ref_syntax(*id).expect("If this is not found, it must be a type ref generated by the library which should never be unresolved.");
                    sink.push(UnresolvedType { file, type_ref });
                }
                InferenceDiagnostic::MismatchedTypes {
                    id,
                    found,
                    expected,
                } => {
                    let file = owner.source(db).file_id;
                    let body = owner.body_source_map(db);
                    let expr = body.expr_syntax(*id).unwrap();
                    sink.push(MismatchedType {
                        file,
                        expr,
                        found: found.clone(),
                        expected: expected.clone(),
                    });
                }
                InferenceDiagnostic::CannotApplyBinaryOp { id, lhs, rhs } => {
                    let file = owner.source(db).file_id;
                    let body = owner.body_source_map(db);
                    let expr = body.expr_syntax(*id).unwrap();
                    sink.push(CannotApplyBinaryOp {
                        file,
                        expr,
                        lhs: lhs.clone(),
                        rhs: rhs.clone(),
                    });
                }
            }
        }
    }
}
