// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borrowed mode, and only
//! this mode has all AST accessors.

use rowan::TransparentNewType;

use crate::{
    SyntaxNode, SyntaxKind::*,
    syntax_node::{TreeArc},
    ast::{self, AstNode},
};


// Block
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Block {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Block {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BLOCK => Some(Block::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Block {
    type Owned = TreeArc<Block>;
    fn to_owned(&self) -> TreeArc<Block> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Block {}


// FunctionDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FunctionDef {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for FunctionDef {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for FunctionDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FUNCTION_DEF => Some(FunctionDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FunctionDef {
    type Owned = TreeArc<FunctionDef>;
    fn to_owned(&self) -> TreeArc<FunctionDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for FunctionDef {}
impl FunctionDef {
    pub fn param_list(&self) -> Option<&ParamList> {
        super::child_opt(self)
    }

    pub fn body(&self) -> Option<&Block> {
        super::child_opt(self)
    }
}


// ModuleItem
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ModuleItem {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ModuleItem {
    type Repr = rowan::SyntaxNode;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModuleItemKind<'a>{
    FunctionDef(&'a FunctionDef),
}
impl<'a> From<&'a FunctionDef> for &'a ModuleItem {
    fn from(n: &'a FunctionDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}

impl AstNode for ModuleItem {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            
            | FUNCTION_DEF => Some(ModuleItem::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ModuleItem {
    type Owned = TreeArc<ModuleItem>;
    fn to_owned(&self) -> TreeArc<ModuleItem> { TreeArc::cast(self.syntax.to_owned()) }
}

impl ModuleItem {
    pub fn kind(&self) -> ModuleItemKind {
        match self.syntax.kind() {
            FUNCTION_DEF => ModuleItemKind::FunctionDef(FunctionDef::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ModuleItem {}


// Name
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Name {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Name {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAME => Some(Name::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Name {
    type Owned = TreeArc<Name>;
    fn to_owned(&self) -> TreeArc<Name> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Name {}


// NameRef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for NameRef {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for NameRef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAME_REF => Some(NameRef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NameRef {
    type Owned = TreeArc<NameRef>;
    fn to_owned(&self) -> TreeArc<NameRef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl NameRef {}


// Param
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Param {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Param {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PARAM => Some(Param::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Param {
    type Owned = TreeArc<Param>;
    fn to_owned(&self) -> TreeArc<Param> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for Param {}
impl ast::TypeAscriptionOwner for Param {}
impl Param {}


// ParamList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for ParamList {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for ParamList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PARAM_LIST => Some(ParamList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ParamList {
    type Owned = TreeArc<ParamList>;
    fn to_owned(&self) -> TreeArc<ParamList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ParamList {}


// SourceFile
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for SourceFile {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for SourceFile {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            SOURCE_FILE => Some(SourceFile::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for SourceFile {
    type Owned = TreeArc<SourceFile>;
    fn to_owned(&self) -> TreeArc<SourceFile> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::ModuleItemOwner for SourceFile {}
impl ast::FunctionDefOwner for SourceFile {}
impl SourceFile {}


// TypeRef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeRef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeRef {
    type Repr = rowan::SyntaxNode;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TypeRefKind<'a>{
    NameRef(&'a NameRef),
}
impl<'a> From<&'a NameRef> for &'a TypeRef {
    fn from(n: &'a NameRef) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}

impl AstNode for TypeRef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            
            | NAME_REF => Some(TypeRef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeRef {
    type Owned = TreeArc<TypeRef>;
    fn to_owned(&self) -> TreeArc<TypeRef> { TreeArc::cast(self.syntax.to_owned()) }
}

impl TypeRef {
    pub fn kind(&self) -> TypeRefKind {
        match self.syntax.kind() {
            NAME_REF => TypeRefKind::NameRef(NameRef::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl TypeRef {}

