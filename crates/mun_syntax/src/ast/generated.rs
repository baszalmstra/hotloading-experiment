// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borrowed mode, and only
//! this mode has all AST accessors.

use rowan::TransparentNewType;

use crate::{
    SyntaxNode, SyntaxKind::*,
    syntax_node::{TreeArc},
    ast::{self, AstNode},
};


// ArgList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for ArgList {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for ArgList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ARG_LIST => Some(ArgList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ArgList {
    type Owned = TreeArc<ArgList>;
    fn to_owned(&self) -> TreeArc<ArgList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ArgList {
    pub fn args(&self) -> impl Iterator<Item = &Expr> {
        super::children(self)
    }
}


// BinExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for BinExpr {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for BinExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BIN_EXPR => Some(BinExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for BinExpr {
    type Owned = TreeArc<BinExpr>;
    fn to_owned(&self) -> TreeArc<BinExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl BinExpr {}


// Block
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Block {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Block {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BLOCK => Some(Block::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Block {
    type Owned = TreeArc<Block>;
    fn to_owned(&self) -> TreeArc<Block> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Block {
    pub fn statements(&self) -> impl Iterator<Item = &Stmt> {
        super::children(self)
    }

    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}


// CallExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for CallExpr {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for CallExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            CALL_EXPR => Some(CallExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for CallExpr {
    type Owned = TreeArc<CallExpr>;
    fn to_owned(&self) -> TreeArc<CallExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl CallExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}


// Expr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Expr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Expr {
    type Repr = rowan::SyntaxNode;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ExprKind<'a>{
    Literal(&'a Literal),
    PrefixExpr(&'a PrefixExpr),
    BinExpr(&'a BinExpr),
    NameRef(&'a NameRef),
    ParenExpr(&'a ParenExpr),
    CallExpr(&'a CallExpr),
}
impl<'a> From<&'a Literal> for &'a Expr {
    fn from(n: &'a Literal) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PrefixExpr> for &'a Expr {
    fn from(n: &'a PrefixExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a BinExpr> for &'a Expr {
    fn from(n: &'a BinExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a NameRef> for &'a Expr {
    fn from(n: &'a NameRef) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ParenExpr> for &'a Expr {
    fn from(n: &'a ParenExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a CallExpr> for &'a Expr {
    fn from(n: &'a CallExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}

impl AstNode for Expr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            
            | LITERAL
            | PREFIX_EXPR
            | BIN_EXPR
            | NAME_REF
            | PAREN_EXPR
            | CALL_EXPR => Some(Expr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Expr {
    type Owned = TreeArc<Expr>;
    fn to_owned(&self) -> TreeArc<Expr> { TreeArc::cast(self.syntax.to_owned()) }
}

impl Expr {
    pub fn kind(&self) -> ExprKind {
        match self.syntax.kind() {
            LITERAL => ExprKind::Literal(Literal::cast(&self.syntax).unwrap()),
            PREFIX_EXPR => ExprKind::PrefixExpr(PrefixExpr::cast(&self.syntax).unwrap()),
            BIN_EXPR => ExprKind::BinExpr(BinExpr::cast(&self.syntax).unwrap()),
            NAME_REF => ExprKind::NameRef(NameRef::cast(&self.syntax).unwrap()),
            PAREN_EXPR => ExprKind::ParenExpr(ParenExpr::cast(&self.syntax).unwrap()),
            CALL_EXPR => ExprKind::CallExpr(CallExpr::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Expr {}


// ExprStmt
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for ExprStmt {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for ExprStmt {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            EXPR_STMT => Some(ExprStmt::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ExprStmt {
    type Owned = TreeArc<ExprStmt>;
    fn to_owned(&self) -> TreeArc<ExprStmt> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ExprStmt {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}


// FunctionDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FunctionDef {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for FunctionDef {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for FunctionDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FUNCTION_DEF => Some(FunctionDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FunctionDef {
    type Owned = TreeArc<FunctionDef>;
    fn to_owned(&self) -> TreeArc<FunctionDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for FunctionDef {}
impl ast::VisibilityOwner for FunctionDef {}
impl ast::TypeAscriptionOwner for FunctionDef {}
impl FunctionDef {
    pub fn param_list(&self) -> Option<&ParamList> {
        super::child_opt(self)
    }

    pub fn body(&self) -> Option<&Block> {
        super::child_opt(self)
    }
}


// LetStmt
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for LetStmt {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for LetStmt {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LET_STMT => Some(LetStmt::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LetStmt {
    type Owned = TreeArc<LetStmt>;
    fn to_owned(&self) -> TreeArc<LetStmt> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for LetStmt {}
impl ast::TypeAscriptionOwner for LetStmt {}
impl LetStmt {}


// Literal
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Literal {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Literal {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LITERAL => Some(Literal::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Literal {
    type Owned = TreeArc<Literal>;
    fn to_owned(&self) -> TreeArc<Literal> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Literal {}


// ModuleItem
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ModuleItem {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ModuleItem {
    type Repr = rowan::SyntaxNode;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModuleItemKind<'a>{
    FunctionDef(&'a FunctionDef),
}
impl<'a> From<&'a FunctionDef> for &'a ModuleItem {
    fn from(n: &'a FunctionDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}

impl AstNode for ModuleItem {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            
            | FUNCTION_DEF => Some(ModuleItem::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ModuleItem {
    type Owned = TreeArc<ModuleItem>;
    fn to_owned(&self) -> TreeArc<ModuleItem> { TreeArc::cast(self.syntax.to_owned()) }
}

impl ModuleItem {
    pub fn kind(&self) -> ModuleItemKind {
        match self.syntax.kind() {
            FUNCTION_DEF => ModuleItemKind::FunctionDef(FunctionDef::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ModuleItem {}


// Name
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Name {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Name {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAME => Some(Name::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Name {
    type Owned = TreeArc<Name>;
    fn to_owned(&self) -> TreeArc<Name> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Name {}


// NameRef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for NameRef {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for NameRef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAME_REF => Some(NameRef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NameRef {
    type Owned = TreeArc<NameRef>;
    fn to_owned(&self) -> TreeArc<NameRef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl NameRef {}


// Param
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Param {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Param {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PARAM => Some(Param::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Param {
    type Owned = TreeArc<Param>;
    fn to_owned(&self) -> TreeArc<Param> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for Param {}
impl ast::TypeAscriptionOwner for Param {}
impl Param {}


// ParamList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for ParamList {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for ParamList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PARAM_LIST => Some(ParamList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ParamList {
    type Owned = TreeArc<ParamList>;
    fn to_owned(&self) -> TreeArc<ParamList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ParamList {
    pub fn params(&self) -> impl Iterator<Item = &Param> {
        super::children(self)
    }
}


// ParenExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for ParenExpr {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for ParenExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PAREN_EXPR => Some(ParenExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ParenExpr {
    type Owned = TreeArc<ParenExpr>;
    fn to_owned(&self) -> TreeArc<ParenExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ParenExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}


// PrefixExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for PrefixExpr {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for PrefixExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PREFIX_EXPR => Some(PrefixExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PrefixExpr {
    type Owned = TreeArc<PrefixExpr>;
    fn to_owned(&self) -> TreeArc<PrefixExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PrefixExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}


// SourceFile
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for SourceFile {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for SourceFile {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            SOURCE_FILE => Some(SourceFile::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for SourceFile {
    type Owned = TreeArc<SourceFile>;
    fn to_owned(&self) -> TreeArc<SourceFile> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::ModuleItemOwner for SourceFile {}
impl ast::FunctionDefOwner for SourceFile {}
impl SourceFile {}


// Stmt
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Stmt {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Stmt {
    type Repr = rowan::SyntaxNode;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StmtKind<'a>{
    LetStmt(&'a LetStmt),
    ExprStmt(&'a ExprStmt),
}
impl<'a> From<&'a LetStmt> for &'a Stmt {
    fn from(n: &'a LetStmt) -> &'a Stmt {
        Stmt::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ExprStmt> for &'a Stmt {
    fn from(n: &'a ExprStmt) -> &'a Stmt {
        Stmt::cast(&n.syntax).unwrap()
    }
}

impl AstNode for Stmt {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            
            | LET_STMT
            | EXPR_STMT => Some(Stmt::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Stmt {
    type Owned = TreeArc<Stmt>;
    fn to_owned(&self) -> TreeArc<Stmt> { TreeArc::cast(self.syntax.to_owned()) }
}

impl Stmt {
    pub fn kind(&self) -> StmtKind {
        match self.syntax.kind() {
            LET_STMT => StmtKind::LetStmt(LetStmt::cast(&self.syntax).unwrap()),
            EXPR_STMT => StmtKind::ExprStmt(ExprStmt::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Stmt {}


// TypeRef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeRef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeRef {
    type Repr = rowan::SyntaxNode;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TypeRefKind<'a>{
    NameRef(&'a NameRef),
}
impl<'a> From<&'a NameRef> for &'a TypeRef {
    fn from(n: &'a NameRef) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}

impl AstNode for TypeRef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            
            | NAME_REF => Some(TypeRef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeRef {
    type Owned = TreeArc<TypeRef>;
    fn to_owned(&self) -> TreeArc<TypeRef> { TreeArc::cast(self.syntax.to_owned()) }
}

impl TypeRef {
    pub fn kind(&self) -> TypeRefKind {
        match self.syntax.kind() {
            NAME_REF => TypeRefKind::NameRef(NameRef::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl TypeRef {}


// Visibility
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}

unsafe impl TransparentNewType for Visibility {
    type Repr = rowan::SyntaxNode;
}

impl AstNode for Visibility {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            VISIBILITY => Some(Visibility::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Visibility {
    type Owned = TreeArc<Visibility>;
    fn to_owned(&self) -> TreeArc<Visibility> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Visibility {}

